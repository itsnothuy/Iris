# Issue #2.5: Production Readiness Consolidation

## üéØ Epic: Production Foundation Hardening
**Priority**: P0 (Critical)  
**Estimate**: 8-12 days  
**Dependencies**: #00 (Project Foundation), #01 (Core Architecture), #02 (Native llama.cpp Integration)  
**Architecture Reference**: [docs/architecture.md](../architecture.md) - All Sections

## üìã Overview
This critical consolidation issue addresses architectural gaps, build system inconsistencies, and missing production-ready components identified in the deep analysis of issues #00-#02. It ensures the foundation is enterprise-grade before proceeding with advanced features.

## üéØ Goals
- **Build System Standardization**: Resolve Java version conflicts and dependency inconsistencies
- **Central Application Orchestration**: Implement missing AppCoordinator, StateManager, and EventBus
- **GPU Backend Activation**: Enable and optimize OpenCL/Vulkan backends for production
- **Performance Management**: Implement thermal controls and memory optimization
- **Production Quality**: Establish comprehensive testing and monitoring infrastructure

## üìù Critical Issues Identified

### üö® Priority 1: Build System Inconsistencies

#### 1.1 Java Version Standardization
**Current Issue**: Mix of Java 11 and Java 17 across modules
```kotlin
// INCONSISTENT: Various modules use different Java versions
// common/build.gradle.kts: JavaVersion.VERSION_11
// Issue #01 specification: Java 17
```

- [ ] **Standardize Java 17 Across All Modules**
  - Update all `build.gradle.kts` files to use `JavaVersion.VERSION_17`
  - Update `compileOptions` and `kotlinOptions.jvmTarget` to "17"
  - Verify Android Gradle Plugin compatibility with Java 17
  - Update CI/CD workflows to use Java 17

- [ ] **Repository Dependency Mode Conflicts**
  - Fix `settings.gradle.kts` vs individual module repository declarations
  - Standardize on `repositoriesMode.set(RepositoriesMode.PREFER_SETTINGS)`
  - Remove redundant repository declarations from module build files

#### 1.2 Ktlint Configuration Missing
**Current Issue**: CI references ktlint but configuration is missing
- [ ] **Create ktlint Configuration**
```yaml
# ktlint.yml
disabled_rules:
  - "import-ordering"
  - "no-wildcard-imports"  # Allow for Compose imports

android: true
experimental: true
```

- [ ] **Pre-commit Hooks Setup**
```bash
#!/bin/bash
# scripts/setup-dev.sh (missing implementation)
echo "Setting up iris_android development environment..."

# Install Git hooks
cp scripts/pre-commit .git/hooks/pre-commit
chmod +x .git/hooks/pre-commit

# Verify ktlint
./gradlew ktlintCheck || exit 1

echo "Development environment setup complete!"
```

### üö® Priority 2: Missing Central Application Orchestration

#### 2.1 AppCoordinator Implementation Missing
**Critical Gap**: No central application coordinator as specified in Issue #01

- [ ] **Implement AppCoordinator**
```kotlin
@Singleton
class AppCoordinator @Inject constructor(
    private val stateManager: StateManager,
    private val eventBus: EventBus,
    private val llmEngine: LLMEngine,
    private val ragEngine: RAGEngine,
    private val safetyEngine: SafetyEngine,
    private val thermalManager: ThermalManager
) {
    
    private val _appState = MutableStateFlow(AppState.Initializing)
    val appState: StateFlow<AppState> = _appState.asStateFlow()
    
    suspend fun initialize(): Result<Unit> {
        return try {
            // Initialize thermal monitoring
            thermalManager.startMonitoring()
            
            // Initialize safety engine
            safetyEngine.initialize()
            
            // Set app state to ready
            _appState.value = AppState.Ready
            
            eventBus.publish(IrisEvent.AppInitialized)
            Result.success(Unit)
        } catch (e: Exception) {
            _appState.value = AppState.Error(e)
            eventBus.publish(IrisEvent.ErrorOccurred(IrisException("App initialization failed", e), "AppCoordinator"))
            Result.failure(e)
        }
    }
    
    suspend fun handleUserRequest(request: UserRequest): ProcessingResult {
        return when (request.type) {
            RequestType.CHAT -> {
                // Coordinate between LLM, Safety, and RAG engines
                val safetyCheck = safetyEngine.checkPrompt(request.content)
                if (!safetyCheck.isAllowed) {
                    return ProcessingResult.Rejected(safetyCheck.reason)
                }
                
                // Check if RAG enhancement is needed
                val ragResults = if (request.requiresRAG) {
                    ragEngine.search(request.content)
                } else emptyList()
                
                // Generate response
                val enhancedPrompt = buildPrompt(request.content, ragResults)
                val response = llmEngine.generateText(enhancedPrompt, request.params)
                
                ProcessingResult.Started(response)
            }
            RequestType.EMBEDDING -> {
                ProcessingResult.Started(llmEngine.embed(request.content))
            }
        }
    }
}

sealed class AppState {
    object Initializing : AppState()
    object Ready : AppState()
    object Processing : AppState()
    object ThermalThrottling : AppState()
    data class Error(val exception: Throwable) : AppState()
}

sealed class ProcessingResult {
    object Started : ProcessingResult()
    data class Rejected(val reason: String) : ProcessingResult()
    data class Error(val exception: Throwable) : ProcessingResult()
    object Completed : ProcessingResult()
}
```

#### 2.2 StateManager Implementation Missing
- [ ] **Implement Centralized State Manager**
```kotlin
@Singleton
class StateManager @Inject constructor(
    private val deviceProfileProvider: DeviceProfileProvider
) {
    
    private val _performanceProfile = MutableStateFlow(PerformanceProfile.BALANCED)
    val performanceProfile: StateFlow<PerformanceProfile> = _performanceProfile.asStateFlow()
    
    private val _deviceState = MutableStateFlow(DeviceState.NORMAL)
    val deviceState: StateFlow<DeviceState> = _deviceState.asStateFlow()
    
    private val _memoryState = MutableStateFlow(MemoryState.NORMAL)
    val memoryState: StateFlow<MemoryState> = _memoryState.asStateFlow()
    
    suspend fun updateThermalState(temperature: Float) {
        _deviceState.value = when {
            temperature > 45.0f -> DeviceState.OVERHEATING
            temperature > 40.0f -> DeviceState.HOT
            else -> DeviceState.NORMAL
        }
        
        // Adjust performance profile based on thermal state
        when (_deviceState.value) {
            DeviceState.OVERHEATING -> _performanceProfile.value = PerformanceProfile.EMERGENCY
            DeviceState.HOT -> _performanceProfile.value = PerformanceProfile.BATTERY_SAVER
            DeviceState.NORMAL -> _performanceProfile.value = PerformanceProfile.BALANCED
        }
    }
    
    suspend fun updateMemoryState(availableMemory: Long) {
        val totalMemory = deviceProfileProvider.getDeviceProfile().totalRAM
        val memoryPercentage = (availableMemory.toDouble() / totalMemory) * 100
        
        _memoryState.value = when {
            memoryPercentage < 10 -> MemoryState.CRITICAL
            memoryPercentage < 25 -> MemoryState.LOW
            else -> MemoryState.NORMAL
        }
    }
}

enum class DeviceState {
    NORMAL, HOT, OVERHEATING
}

enum class MemoryState {
    NORMAL, LOW, CRITICAL
}

enum class PerformanceProfile {
    PERFORMANCE, BALANCED, BATTERY_SAVER, EMERGENCY
}
```

#### 2.3 EventBus System Missing
- [ ] **Implement Event-Driven Communication**
```kotlin
@Singleton
class EventBus @Inject constructor() {
    
    private val _events = MutableSharedFlow<IrisEvent>(
        replay = 0,
        extraBufferCapacity = 64,
        onBufferOverflow = BufferOverflow.DROP_OLDEST
    )
    
    val events: SharedFlow<IrisEvent> = _events.asSharedFlow()
    
    suspend fun publish(event: IrisEvent) {
        _events.emit(event)
    }
    
    inline fun <reified T : IrisEvent> subscribe(): Flow<T> {
        return events.filterIsInstance<T>()
    }
}

sealed class IrisEvent {
    object AppInitialized : IrisEvent()
    data class ModelLoaded(val handle: ModelHandle) : IrisEvent()
    data class ModelUnloaded(val modelId: String) : IrisEvent()
    data class GenerationStarted(val sessionId: Long) : IrisEvent()
    data class GenerationCompleted(val sessionId: Long) : IrisEvent()
    data class ThermalStateChanged(val state: DeviceState) : IrisEvent()
    data class MemoryWarning(val state: MemoryState) : IrisEvent()
    data class ErrorOccurred(val error: IrisException, val component: String) : IrisEvent()
}
```

### üö® Priority 3: GPU Backend Activation & Optimization

#### 3.1 Enable GPU Backends in CMake
**Current Issue**: GPU backends disabled in CMakeLists.txt

- [ ] **Enable Multi-Backend Support**
```cmake
# core-llm/src/main/cpp/CMakeLists.txt - UPDATED
set(GGML_OPENCL ON CACHE BOOL "Enable OpenCL backend")
set(GGML_VULKAN ON CACHE BOOL "Enable Vulkan backend") 
set(GGML_NATIVE ON CACHE BOOL "Enable native optimizations")

# Device-specific optimizations
if(CMAKE_ANDROID_ARCH_ABI STREQUAL "arm64-v8a")
    set(GGML_CPU_ARM_ARCH "armv8.2-a+fp16+dotprod" CACHE STRING "ARM architecture for Snapdragon/Exynos")
elseif(CMAKE_ANDROID_ARCH_ABI STREQUAL "armeabi-v7a")
    set(GGML_CPU_ARM_ARCH "armv7-a+neon" CACHE STRING "ARM architecture for ARMv7")
endif()

# Link OpenCL for Adreno GPUs
find_package(OpenCL REQUIRED)
target_link_libraries(iris_llm OpenCL::OpenCL)

# Link Vulkan for Mali/Xclipse GPUs  
find_package(Vulkan REQUIRED)
target_link_libraries(iris_llm Vulkan::Vulkan)
```

- [ ] **Backend Detection & Routing Implementation**
```cpp
// backend_detector.cpp - NEW FILE
#include "backend_detector.h"
#include <android/log.h>

BackendCapabilities BackendDetector::detectCapabilities() {
    BackendCapabilities caps;
    
    // Detect OpenCL (Adreno GPUs)
    caps.openclAvailable = checkOpenCLSupport();
    if (caps.openclAvailable) {
        caps.openclDevices = enumerateOpenCLDevices();
    }
    
    // Detect Vulkan (Mali/Xclipse GPUs)
    caps.vulkanAvailable = checkVulkanSupport();
    if (caps.vulkanAvailable) {
        caps.vulkanVersion = getVulkanVersion();
    }
    
    // Detect CPU capabilities
    caps.cpuFeatures = detectCPUFeatures();
    
    return caps;
}

OptimalBackend BackendDetector::selectOptimalBackend(
    const BackendCapabilities& caps, 
    ComputeTask task) {
    
    switch (task) {
        case ComputeTask::LLM_INFERENCE:
            // Prefer GPU for large models, CPU for small models
            if (caps.openclAvailable && modelSize > 3_GB) {
                return OptimalBackend{BackendType::OPENCL_ADRENO, 32}; // GPU layers
            }
            if (caps.vulkanAvailable && modelSize > 3_GB) {
                return OptimalBackend{BackendType::VULKAN_MALI, 28}; // GPU layers  
            }
            return OptimalBackend{BackendType::CPU_NEON, 0}; // CPU only
            
        case ComputeTask::EMBEDDING_GENERATION:
            // Embeddings benefit from GPU parallelization
            if (caps.openclAvailable) {
                return OptimalBackend{BackendType::OPENCL_ADRENO, -1}; // All layers
            }
            return OptimalBackend{BackendType::CPU_NEON, 0};
            
        default:
            return OptimalBackend{BackendType::CPU_NEON, 0};
    }
}
```

#### 3.2 Thermal Management & Performance Controls
- [ ] **Implement Thermal Manager**
```kotlin
@Singleton  
class ThermalManagerImpl @Inject constructor(
    private val context: Context,
    private val stateManager: StateManager
) : ThermalManager {
    
    private val thermalService = context.getSystemService(Context.THERMAL_SERVICE) as? ThermalManager
    private var isMonitoring = false
    
    override suspend fun startMonitoring() {
        if (isMonitoring) return
        isMonitoring = true
        
        // Android 11+ thermal monitoring
        thermalService?.let { service ->
            val callback = object : ThermalManager.OnThermalStatusChangedListener {
                override fun onThermalStatusChanged(status: Int) {
                    handleThermalStatusChange(status)
                }
            }
            service.addThermalStatusListener(callback)
        }
        
        // Fallback polling for older Android versions
        startTemperaturePolling()
    }
    
    private fun handleThermalStatusChange(status: Int) {
        val temperature = when (status) {
            ThermalManager.THERMAL_STATUS_NONE -> 25.0f
            ThermalManager.THERMAL_STATUS_LIGHT -> 35.0f
            ThermalManager.THERMAL_STATUS_MODERATE -> 40.0f
            ThermalManager.THERMAL_STATUS_SEVERE -> 45.0f
            ThermalManager.THERMAL_STATUS_CRITICAL -> 50.0f
            ThermalManager.THERMAL_STATUS_EMERGENCY -> 55.0f
            else -> 25.0f
        }
        
        lifecycleScope.launch {
            stateManager.updateThermalState(temperature)
        }
    }
    
    override suspend fun getOptimalPerformance(): PerformanceProfile {
        return when (stateManager.deviceState.value) {
            DeviceState.OVERHEATING -> PerformanceProfile.EMERGENCY
            DeviceState.HOT -> PerformanceProfile.BATTERY_SAVER
            DeviceState.NORMAL -> PerformanceProfile.BALANCED
        }
    }
}
```

### üö® Priority 4: Production Testing Infrastructure

#### 4.1 Integration Testing Framework
- [ ] **Create Comprehensive Integration Tests**
```kotlin
@RunWith(AndroidJUnit4::class)
@HiltAndroidTest
class ProductionIntegrationTest {
    
    @get:Rule
    var hiltRule = HiltAndroidRule(this)
    
    @Inject
    lateinit var appCoordinator: AppCoordinator
    
    @Inject  
    lateinit var llmEngine: LLMEngine
    
    @Test
    fun `full app initialization succeeds`() = runTest {
        hiltRule.inject()
        
        val result = appCoordinator.initialize()
        
        assertTrue(result.isSuccess)
        assertEquals(AppState.Ready, appCoordinator.appState.first { it != AppState.Initializing })
    }
    
    @Test
    fun `end to end model loading and inference`() = runTest {
        // Requires test model file in androidTest/assets/
        val testModelPath = extractTestModel()
        
        val loadResult = llmEngine.loadModel(testModelPath)
        assertTrue(loadResult.isSuccess)
        
        val handle = loadResult.getOrThrow()
        val response = llmEngine.generateText("Hello", GenerationParams()).first()
        
        assertNotNull(response)
        assertTrue(response.isNotEmpty())
    }
    
    @Test
    fun `thermal throttling triggers performance adjustment`() = runTest {
        val thermalManager = appCoordinator.thermalManager
        
        // Simulate high temperature
        thermalManager.simulateTemperature(50.0f) // Test method
        
        delay(100) // Allow state propagation
        
        val profile = thermalManager.getOptimalPerformance()
        assertEquals(PerformanceProfile.EMERGENCY, profile)
    }
}
```

#### 4.2 Performance Benchmarking
- [ ] **Implement Performance Monitoring**
```kotlin
@Singleton
class PerformanceMonitor @Inject constructor() {
    
    data class BenchmarkResult(
        val inferenceSpeed: Float, // tokens/second
        val memoryUsage: Long,     // bytes
        val batteryDrain: Float,   // percentage/minute
        val thermalIncrease: Float // degrees C
    )
    
    suspend fun runBenchmark(modelPath: String): BenchmarkResult {
        val startTime = System.currentTimeMillis()
        val startMemory = getUsedMemory()
        val startBattery = getBatteryLevel()
        val startTemperature = getCPUTemperature()
        
        // Load model and run inference
        val handle = llmEngine.loadModel(modelPath).getOrThrow()
        val tokens = mutableListOf<String>()
        
        llmEngine.generateText("Benchmark prompt", GenerationParams(maxTokens = 100))
            .collect { token -> tokens.add(token) }
        
        val endTime = System.currentTimeMillis()
        val endMemory = getUsedMemory()  
        val endBattery = getBatteryLevel()
        val endTemperature = getCPUTemperature()
        
        val duration = (endTime - startTime) / 1000.0f
        val tokensPerSecond = tokens.size / duration
        val memoryDelta = endMemory - startMemory
        val batteryDelta = (startBattery - endBattery) / (duration / 60.0f)
        val tempDelta = endTemperature - startTemperature
        
        return BenchmarkResult(tokensPerSecond, memoryDelta, batteryDelta, tempDelta)
    }
}
```

#### 4.3 Memory Leak Detection
- [ ] **Memory Management Validation**
```kotlin
@Test
fun `no memory leaks during sustained inference`() = runTest {
    val initialMemory = getUsedMemory()
    
    // Run 100 inference cycles
    repeat(100) {
        val response = llmEngine.generateText("Test prompt", GenerationParams(maxTokens = 10))
        response.collect { /* consume */ }
        
        // Force GC periodically
        if (it % 10 == 0) {
            System.gc()
            delay(100)
        }
    }
    
    System.gc()
    delay(1000) // Allow cleanup
    
    val finalMemory = getUsedMemory()
    val memoryGrowth = finalMemory - initialMemory
    
    // Memory growth should be minimal (<50MB for sustained usage)
    assertTrue("Memory leak detected: ${memoryGrowth / 1024 / 1024}MB growth", 
               memoryGrowth < 50 * 1024 * 1024)
}
```

## üß™ Testing Strategy

### Unit Tests
- [ ] AppCoordinator initialization and error handling
- [ ] StateManager state transitions and edge cases  
- [ ] EventBus message delivery and ordering
- [ ] ThermalManager temperature monitoring and thresholds
- [ ] BackendDetector capability detection accuracy

### Integration Tests  
- [ ] Full application lifecycle (init ‚Üí ready ‚Üí processing ‚Üí shutdown)
- [ ] Cross-module communication via EventBus
- [ ] Performance profile adaptation under thermal stress
- [ ] Memory management under sustained load
- [ ] GPU backend fallback scenarios

### Performance Tests
- [ ] Benchmark suite across device types (flagship, mid-range, low-end)
- [ ] Battery consumption profiling
- [ ] Thermal behavior under extended inference
- [ ] Memory usage patterns and leak detection
- [ ] Backend switching performance impact

## ‚úÖ Acceptance Criteria

### Technical Criteria
- [ ] **Build System**: All modules use Java 17, no dependency conflicts
- [ ] **Architecture**: AppCoordinator, StateManager, EventBus fully functional
- [ ] **GPU Backends**: OpenCL and Vulkan enabled and working on compatible devices
- [ ] **Performance**: Thermal management prevents overheating, optimal backend selection
- [ ] **Memory**: No memory leaks during sustained usage, efficient cleanup

### Quality Criteria  
- [ ] **Test Coverage**: >95% coverage on new orchestration components
- [ ] **Performance Benchmarks**: Meet specified targets (tokens/sec, memory, battery)
- [ ] **Error Handling**: Graceful degradation and recovery from all error scenarios
- [ ] **Documentation**: All new components fully documented
- [ ] **Integration**: Seamless interaction between all architectural layers

### Production Criteria
- [ ] **Stability**: No crashes during 4-hour continuous inference testing
- [ ] **Thermal Safety**: No device shutdowns or performance throttling under normal load
- [ ] **Resource Efficiency**: Optimal memory and battery usage profiles
- [ ] **Scalability**: Architecture supports future feature additions without refactoring

## üîó Related Issues
- **Addresses gaps from**: #00, #01, #02
- **Enables**: #03, #04, #05 (Hardware Detection, Model Management, Chat Engine)
- **Blocks**: All subsequent feature development until architectural foundation is solid

## üìã Definition of Done
- [ ] All identified architectural gaps resolved
- [ ] Build system standardized and conflict-free
- [ ] Central orchestration (AppCoordinator, StateManager, EventBus) operational
- [ ] GPU backends enabled and optimized for Android
- [ ] Comprehensive testing infrastructure validates production readiness
- [ ] Performance monitoring and thermal management prevent device issues
- [ ] Memory management robust under sustained load
- [ ] All acceptance criteria verified and documented
- [ ] Code review completed with architecture team approval
- [ ] Integration testing passes on representative device matrix

---

**Critical Note**: This consolidation issue must be completed before proceeding with Issues #03-#16. The identified gaps represent production-blocking architectural deficiencies that will cause instability and poor user experience if not addressed at this foundational level.

The current implementation is approximately 85% complete but lacks critical production hardening that this issue provides. Completing Issue #2.5 will establish a robust, enterprise-grade foundation for all subsequent feature development.